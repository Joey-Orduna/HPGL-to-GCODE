using HPGL_;
using MahApps.Metro.Controls;
using System;
using System.Globalization;
using System.IO;
using System.Text;
using System.Threading;
using System.Windows;
using System.Windows.Media;
using System.Windows.Threading;
using WinShapes = System.Windows.Shapes;

namespace HPGL_to_GCODE
{
    /// <summary>
    /// Interaktionslogik für MainWindow.xaml
    /// </summary>
    public partial class MainWindow : MetroWindow
    {
        float sizeX = 0, sizeY = 0;
        string outputCode = string.Empty;
        HPGL _hpgl = new HPGL();
        const float resolution = 0.025f;
        DispatcherTimer timer = new DispatcherTimer();
        ProfileManager manager;
        string xmlFile = @".\profiles.xml";
        string hpglfile = string.Empty;

        public MainWindow()
        {
            InitializeComponent();
            manager = ProfileManager.LoadFromFile(xmlFile);

            timer.Interval = TimeSpan.FromMilliseconds(50);
            timer.Tick += Timer_Tick;

            //Punkt als Dezimaltrennzeichen einstellen
            NumberFormatInfo info = (NumberFormatInfo)NumberFormatInfo.CurrentInfo.Clone();
            info.NumberDecimalSeparator = ".";
            CultureInfo culture = (CultureInfo)Thread.CurrentThread.CurrentCulture.Clone();
            culture.NumberFormat = info;
            Thread.CurrentThread.CurrentCulture = culture;
        }

        private void ReadHpglFile(string filename)
        {
            StreamReader reader = new StreamReader(filename);
            _hpgl = HPGL.Parse(reader.ReadToEnd());
            UpdateInfos();
            DrawPath();
        }

        private string CreateGcodeFromHpgl(HPGL hpgl)
        {
            Profile p = null;

            if (manager.Profiles.Count == 1)
            {
                p = manager.Profiles[0];
            }
            else
            {
                ProfileWindow window = new ProfileWindow(manager, ProfileWindow.WindowMode.SelectData);
                window.ShowDialog();
                p = window.SelectedProfile;
            }
            if (p == null)
            {
                MessageBox.Show("Error while loading profile");
                return String.Empty;
            }

            StringBuilder GCode = new StringBuilder();
            //GCode.AppendFormat("; Generated by HPGL-to-GCODE\r\n; Profile: {0}\r\n", p.Profilename);

            float endstopOffset = p.EndstopOffset;
            float materialThickness = p.MaterialThickness;
            float paperThickness = p.PaperThickness;
            float paperPenetration = p.PaperPenetraion / 100;
            float safeDistance = p.SafeDistance;
            float feedrate = p.Feedrate;
            string startCode = p.StartCode;
            string endCode = p.EndCode;

            float depthOfCut = materialThickness - paperThickness + (paperThickness * paperPenetration);

            if (startCode.Length > 0)
            {
                startCode = startCode.Replace("{height}", (endstopOffset + materialThickness + safeDistance).ToString());
                startCode = startCode.Replace("{feed}", (feedrate * 60).ToString());
                GCode.AppendLine(startCode);
            }

            foreach (var command in _hpgl.Commands)
            {
                switch (command.Instruction)
                {
                    case HPGL.Instruction.PU:
                        GCode.AppendLine($"G1 Z{endstopOffset + materialThickness + safeDistance}");
                        break;
                    case HPGL.Instruction.PD:
                        GCode.AppendLine($"G1 Z{endstopOffset + materialThickness - depthOfCut}");
                        break;
                }

                for (int i = 0; i < command.Coordinates.Count; i++)
                {
                    float x = (float)command.Coordinates[i].X * resolution;
                    float y = (float)command.Coordinates[i].Y * resolution;

                    GCode.AppendLine($"G1 X{x} Y{y}");
                }
            }

            if (endCode.Length > 0)
                GCode.Append(endCode);

            outputCode = GCode.ToString();
            return outputCode;
        }

        private void DrawPath()
        {
            float factor = 1;

            if (sizeX / canvas1.ActualWidth > sizeY / canvas1.ActualHeight)
                factor = (float)canvas1.ActualWidth / sizeX;
            else
                factor = (float)canvas1.ActualHeight / sizeY;

            var rendered = RenderHpglToPath(_hpgl, factor, (float)canvas1.ActualHeight);

            int deltaChildren = canvas1.Children.Count - rendered.Length;

            if (deltaChildren > 0)
            {
                canvas1.Children.RemoveRange(0, deltaChildren);
            }
            else if (deltaChildren < 0)
            {
                for (int i = 0; i < Math.Abs(deltaChildren); i++)
                {
                    canvas1.Children.Add(new WinShapes.Path());
                }
            }

            for (int i = 0; i < rendered.Length - 1; i++)
            {
                if (rendered[i] == null)
                    continue;
                ((WinShapes.Path)canvas1.Children[i]).Data = rendered[i].Data;
                ((WinShapes.Path)canvas1.Children[i]).Stroke = rendered[i].Stroke;
                ((WinShapes.Path)canvas1.Children[i]).StrokeThickness = rendered[i].StrokeThickness;
                ((WinShapes.Path)canvas1.Children[i]).Opacity = rendered[i].Opacity;
            }
        }

        private void UpdateInfos()
        {
            int linecount = 0;
            sizeX = sizeY = 0;

            foreach (var cmd in _hpgl.Commands)
            {
                for (int i = 0; i < cmd.Coordinates.Count; i++)
                {
                    sizeX = (float)Math.Max(sizeX, cmd.Coordinates[i].X);
                    sizeY = (float)Math.Max(sizeY, cmd.Coordinates[i].Y);
                    linecount++;
                }
            }

            double actualSizeX;
            double actualSizeY;

            if (float.IsNaN(sizeX) || float.IsNaN(sizeY))
            {
                actualSizeX = actualSizeY = 0;
            }
            else
            {
                actualSizeX = Math.Ceiling(sizeX * resolution);
                actualSizeY = Math.Ceiling(sizeY * resolution);
            }

            sizeLabel.Content = string.Format("{0} x {1} mm", actualSizeX.ToString(), actualSizeY.ToString());
            lineCountLabel.Content = linecount.ToString();
        }

        private WinShapes.Path DrawRect(float sizeX, float sizeY, float factor, float height)
        {
            WinShapes.Path path = new WinShapes.Path();
            StreamGeometry geometry = new StreamGeometry();
            path.Stroke = Brushes.DarkGray;
            path.StrokeThickness = 1;
            path.Opacity = 1;
            using (StreamGeometryContext context = geometry.Open())
            {
                context.BeginFigure(new Point(0, height), false, false);
                context.LineTo(new Point(sizeX * factor, height), true, false);
                context.LineTo(new Point(sizeX * factor, height - (sizeY * factor)), true, false);
                context.LineTo(new Point(0, height - (sizeY * factor)), true, false);
                context.LineTo(new Point(0, height), true, false);
            }
            geometry.Freeze();
            path.Data = geometry;
            return path;
        }

        private WinShapes.Path[] RenderHpglToPath(HPGL hpgl, float factor, float height)
        {
            WinShapes.Path[] pathCollection = new WinShapes.Path[hpgl.Commands.Capacity + 1];
            pathCollection[0] = DrawRect(sizeX, sizeY, factor, height);
            Point lastpoint = new Point(0, height);

            for (int i = 1; i < hpgl.Commands.Count; i++)
            {
                WinShapes.Path path = new WinShapes.Path();
                StreamGeometry geometry = new StreamGeometry();
                HPGL.Command cmd = hpgl.Commands[i];

                if (cmd.Instruction == HPGL.Instruction.Undefined)
                    continue;

                else if (cmd.Instruction == HPGL.Instruction.PD)
                {
                    path.Stroke = Brushes.Crimson;
                    path.StrokeThickness = 1.5;
                    path.Opacity = 0.8;
                }
                else if (cmd.Instruction == HPGL.Instruction.PU)
                {
                    path.Stroke = Brushes.Blue;
                    path.StrokeThickness = 1.5;
                    path.Opacity = 0.4;
                }

                using (StreamGeometryContext context = geometry.Open())
                {
                    context.BeginFigure(lastpoint, false, false);

                    for (int j = 0; j < cmd.Coordinates.Count; j++)
                    {
                        Point nextPoint = new Point(cmd.Coordinates[j].X * factor, height - (cmd.Coordinates[j].Y * factor));
                        context.LineTo(nextPoint, true, false);
                    }
                    lastpoint = new Point(cmd.Coordinates[cmd.Coordinates.Count - 1].X * factor, height - (cmd.Coordinates[cmd.Coordinates.Count - 1].Y * factor));
                }
                geometry.Freeze();
                path.Data = geometry;
                pathCollection[i] = path;
            }

            return pathCollection;
        }

        private void Window_SizeChanged(object sender, SizeChangedEventArgs e)
        {
            timer.Stop();
            timer.Start();
        }

        private void Timer_Tick(object sender, EventArgs e)
        {
            timer.Stop();
            DrawPath();
        }

        private void selectFileButton_Click(object sender, RoutedEventArgs e)
        {
            if (manager.Profiles.Count == 0)
            {
                MessageBox.Show("Please configure a new profile.");
                return;
            }

            Microsoft.Win32.OpenFileDialog fileDialog = new Microsoft.Win32.OpenFileDialog()
            {
                DefaultExt = ".hpgl",
                Filter = "HPGL Files (.hpgl)|*.hpgl"
            };
            bool? result = fileDialog.ShowDialog();
            if (result == true)
            {
                hpglfile = fileDialog.FileName;
                ReadHpglFile(hpglfile);
            }
        }

        private void settingsButton_Click(object sender, RoutedEventArgs e)
        {
            ProfileWindow profiles = new ProfileWindow(manager, ProfileWindow.WindowMode.EditData);
            profiles.ShowDialog();
        }

        private void saveGcodeButton_Click(object sender, RoutedEventArgs e)
        {
            if (_hpgl.Commands.Count > 0)
            {
                outputCode = CreateGcodeFromHpgl(_hpgl);

                if (outputCode.Length > 0)
                {
                    string outFileName = hpglfile.Substring(hpglfile.LastIndexOf("\\") + 1);
                    Microsoft.Win32.SaveFileDialog fileDialog = new Microsoft.Win32.SaveFileDialog()
                    {
                        DefaultExt = ".gcode",
                        Filter = "GCODE Files (.gcode)|*.gcode",
                        FileName = outFileName.Remove(outFileName.Length - 5, 5)
                    };
                    bool? result = fileDialog.ShowDialog();
                    if (result == true)
                    {
                        StreamWriter writer = new StreamWriter(fileDialog.FileName);
                        writer.WriteLine(outputCode);
                        writer.Flush();
                        writer.Close();
                    }
                }
                else
                {
                    MessageBox.Show("Error creating output file. GCODE buffer is empty.");
                    return;
                }
            }
            else
                MessageBox.Show("No HPGL file chosen.");
        }
    }
}